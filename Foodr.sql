-- Calculating REVENUE
SELECT
	ORDER_ID,
	SUM(MEAL_PRICE * ORDER_QUANTITY) AS REVENUE
FROM
	ORDERS
	JOIN MEALS USING (MEAL_ID)
GROUP BY
	ORDER_ID
ORDER BY
	ORDER_ID
	
	
-- Calculating Cost
SELECT
	MEAL_ID,
	SUM(MEAL_COST * STOCKED_QUANTITY) AS TOTAL_COST
FROM
	MEALS
	JOIN STOCK USING (MEAL_ID)
GROUP BY
	MEAL_ID
ORDER BY
	TOTAL_COST DESC

	
-- Using Common Table Expression
WITH
	COSTS_AND_QUANTITES AS (
		SELECT
			M.MEAL_ID,
			S.STOCKED_QUANTITY AS QUANTITY,
			SUM(M.MEAL_COST * S.STOCKED_QUANTITY) AS COST
		FROM
			MEALS AS M
			JOIN STOCK AS S USING (MEAL_ID)
		GROUP BY
			M.MEAL_ID,
			S.STOCKED_QUANTITY
	)
SELECT
	*
FROM
	COSTS_AND_QUANTITES
ORDER BY COST DESC
LIMIT 3;

-- Bringing Revenue and Cost Together- Calculating Profit
WITH
	REVENUES AS (
		SELECT
			M.MEAL_ID,
			SUM(M.MEAL_PRICE * O.ORDER_QUANTITY) AS REVENUE
		FROM
			ORDERS AS O
			JOIN MEALS AS M USING (MEAL_ID)
		GROUP BY
			M.MEAL_ID
	),
	COSTS AS (
		SELECT
			M.MEAL_ID,
			SUM(M.MEAL_COST * S.STOCKED_QUANTITY) AS COST
		FROM
			MEALS AS M
			JOIN STOCK AS S USING (MEAL_ID)
		GROUP BY
			M.MEAL_ID
	)
SELECT
	R.MEAL_ID,
	R.REVENUE,
	C.COST,
	(R.REVENUE - C.COST) AS PROFIT
FROM
	REVENUES AS R
	JOIN COSTS AS C USING (MEAL_ID)
ORDER BY
	PROFIT DESC
LIMIT 3;

-- REGISTRATION SETUP
-- calculate first three user registration
SELECT
	USER_ID,
	MIN(ORDER_DATE)
FROM
	ORDERS
GROUP BY USER_ID
ORDER BY USER_ID
LIMIT 3;

-- User Registrations as per month
WITH
	REG_USERS AS (
		SELECT
			USER_ID,
			MIN(ORDER_DATE) AS REG_DATE
		FROM
			ORDERS
		GROUP BY
			USER_ID
	)
SELECT
	DATE_TRUNC('month', REG_DATE)::DATE AS FOODR_MONTH,
	COUNT(DISTINCT USER_ID) AS REGS
FROM
	REG_USERS
GROUP BY
	FOODR_MONTH
	ORDER BY
	FOODR_MONTH ASC


-- Active Users (Monthly)
SELECT
	DATE_TRUNC('month', ORDER_DATE)::DATE AS FOODR_MONTH,
	COUNT(DISTINCT USER_ID) AS MAU
FROM
	ORDERS
GROUP BY
	FOODR_MONTH
ORDER BY
	FOODR_MONTH



-- Registration running total
WITH REG_USERS AS (
		SELECT USER_ID, MIN(ORDER_DATE) AS REG_DATE
		FROM ORDERS
		GROUP BY USER_ID),
	REGISTRATIONS AS (
		SELECT DATE_TRUNC('month', REG_DATE)::DATE AS FOODR_MONTH,
			COUNT(DISTINCT USER_ID) AS NUM_OF_REGISTRATIONS
		FROM REG_USERS
		GROUP BY FOODR_MONTH)
SELECT FOODR_MONTH, NUM_OF_REGISTRATIONS,
	SUM(NUM_OF_REGISTRATIONS) OVER (ORDER BY FOODR_MONTH) AS REGS_RT
FROM REGISTRATIONS
ORDER BY FOODR_MONTH



-- Lagged MAU - query (get previous month active user)
WITH
	MAUS AS (
		SELECT
			DATE_TRUNC('month', ORDER_DATE)::DATE AS FOODR_MONTH,
			COUNT(DISTINCT USER_ID) AS MAU
		FROM
			ORDERS
		GROUP BY
			FOODR_MONTH
	)
SELECT
	FOODR_MONTH,
	MAU,
	COALESCE(
		LAG(MAU) OVER (
			ORDER BY
				FOODR_MONTH ASC
		),
		1
	) AS LAST_MAU
FROM
	MAUS
ORDER BY FOODR_MONTH ASC 
LIMIT 3;


-- Deltas-query (finding difference of monthly active users)
	
WITH
	MAUS AS (
		SELECT
			DATE_TRUNC('month', ORDER_DATE)::DATE AS FOODR_MONTH,
			COUNT(DISTINCT USER_ID) AS MAU
		FROM
			ORDERS
		GROUP BY
			FOODR_MONTH
	),
	MAUS_LAG AS (
		SELECT
			FOODR_MONTH,
			MAU,
			COALESCE(
				LAG(MAU) OVER (
					ORDER BY
						FOODR_MONTH ASC
				),
				1
			) AS LAST_MAU
		FROM
			MAUS
	)
SELECT
	FOODR_MONTH,
	MAU,
	(MAU - LAST_MAU) AS MAU_DELTA
FROM	MAUS_LAG


	
-- Growth Rate (Calculating growth rate )
WITH
	MAUS AS (
		SELECT
			DATE_TRUNC('month', ORDER_DATE)::DATE AS FOODR_MONTH,
			COUNT(DISTINCT USER_ID) AS MAU
		FROM
			ORDERS
		GROUP BY
			FOODR_MONTH
	),
	MAUS_LAG AS (
		SELECT
			FOODR_MONTH,
			MAU,
			COALESCE(
				LAG(MAU) OVER (
					ORDER BY
						FOODR_MONTH ASC
				),
				1
			) AS LAST_MAU
		FROM
			MAUS
	)
SELECT
	FOODR_MONTH,
	MAU,
	ROUND((MAU - LAST_MAU)::NUMERIC / LAST_MAU, 2) AS GROWTH
FROM
	MAUS_LAG
ORDER BY FOODR_MONTH 
LIMIT 3;


-- RETENTION RATE
WITH
	USER_ACTIVITY AS (
		SELECT DISTINCT
			DATE_TRUNC('month', ORDER_DATE)::DATE AS FOODR_MONTH,
			USER_ID
		FROM
			ORDERS
	)
SELECT
	PREVIOUS.FOODR_MONTH,
	ROUND(
		COUNT(DISTINCT CURRENT.USER_ID)::NUMERIC / GREATEST(COUNT(DISTINCT PREVIOUS.USER_ID), 1),
		2
	) AS RETENTION
FROM
	USER_ACTIVITY AS PREVIOUS
	LEFT JOIN USER_ACTIVITY AS CURRENT ON PREVIOUS.USER_ID = CURRENT.USER_ID
	AND PREVIOUS.FOODR_MONTH = (CURRENT.FOODR_MONTH - INTERVAL '1 month')
GROUP BY
	PREVIOUS.FOODR_MONTH
ORDER BY PREVIOUS.FOODR_MONTH ASC
LIMIT 3;

-- ARPU (Average Revenue Per User)

WITH
	TOTAL_REV AS (
		SELECT
			SUM(M.MEAL_PRICE * O.ORDER_QUANTITY) AS REVENUE,
			COUNT(DISTINCT O.USER_ID) AS USERS
		FROM
			MEALS AS M
			JOIN ORDERS AS O ON M.MEAL_ID = O.MEAL_ID
	)
SELECT
	ROUND((REVENUE::NUMERIC) / GREATEST(USERS, 1), 2) AS AVG_REV_PER_USER
FROM
	TOTAL_REV

-- Average Revenue (monthly basis)
WITH
	MONTHLY_REVENUES AS (
		SELECT
			DATE_TRUNC('month', ORDER_DATE)::DATE AS DELIVERY_MONTH,
			SUM(MEAL_PRICE * ORDER_QUANTITY) AS REVENUE,
			COUNT(DISTINCT USER_ID) AS USERS
		FROM
			MEALS AS M
			JOIN ORDERS AS O ON M.MEAL_ID = O.MEAL_ID
		GROUP BY DELIVERY_MONTH
		ORDER BY DELIVERY_MONTH
	)
SELECT
	DELIVERY_MONTH,
	ROUND(REVENUE::NUMERIC / GREATEST(USERS, 1), 2) AS AVG_REV_PER_USER
FROM
	MONTHLY_REVENUES ORDERBY
	DELIVERY_MONTH ASC;
	
-- Query II (per user then average):
WITH
	USER_REVENUES AS (
		SELECT
			USER_ID,
			SUM(MEAL_PRICE * ORDER_QUANTITY) AS REVENUE
		FROM
			MEALS
			JOIN ORDERS ON MEALS.MEAL_ID = ORDERS.MEAL_ID
		GROUP BY
			USER_ID
	)
SELECT
	ROUND(AVG(REVENUE)::NUMERIC, 2) AS ARPU
FROM
	USER_REVENUES;
	
-- HISTOGRAMS

-- 1) Orders per user:
WITH user_orders AS(
	SELECT
		user_id,
		COUNT(distinct order_id) AS num_of_orders
	FROM orders
	GROUP BY user_id
	ORDER BY user_id
)

-- 2) Revenues rounded to 100s
WITH
	USER_REVENUES AS (
		SELECT
			USER_ID,
			SUM(MEAL_PRICE * ORDER_QUANTITY) AS REVENUE
		FROM
			MEALS AS M
			JOIN ORDERS AS O ON M.MEAL_ID = O.MEAL_ID
		GROUP BY USER_ID
	)
SELECT
	COUNT(DISTINCT USER_ID) AS USERS,
	ROUND(REVENUE::NUMERIC, -2) AS REVENUE_100
FROM
	USER_REVENUES
GROUP BY
	REVENUE_100 ORDER BY
	REVENUE_100 ASC

-- BUCKETING
-- TOP 5 order counts:
WITH
	USER_ORDERS AS (
		SELECT
			USER_ID,
			COUNT(DISTINCT ORDER_ID) AS ORDERS
		FROM
			ORDERS
		GROUP BY
			USER_ID
	)
SELECT
	ORDERS,
	COUNT(DISTINCT USER_ID) AS USERS
FROM
	USER_ORDERS
GROUP BY ORDERS
ORDER BY ORDERS DESC
LIMIT 5;

-- meal price bucketing using CASE:
SELECT
	CASE
		WHEN MEAL_PRICE < 4 THEN 'Low-price-meal'
		WHEN MEAL_PRICE < 6 THEN 'Mid-price-meal'
		ELSE 'High-price meal'
	END AS PRICE_CATEGORY,
	COUNT(DISTINCT MEAL_ID)
FROM
	MEALS
GROUP BY
	PRICE_CATEGORY

-- Revenue bucketing using CASE
WITH user_revenues AS (
	SELECT user_id,
		SUM(meal_price * order_quantity) AS revenue
	fRom meals as m
	JOIN orders as o 
	on m.meal_id = o.meal_id
	group by user_id
)
SELECT 
	CASE 
		WHEN revenue < 150 THEN 'Low-revenue users'
		WHEN revenue < 300 THEN 'Mid-revenue users'
		ELSE 'High-revenue users'
	END AS revenue_group,
	COUNT (DISTINCT user_id) AS users
FROM
	user_revenues
GROUP BY revenue_group

-- PERCENTILE AND QUARTILES

-- percentile and average orders per user:
WITH user_orders AS ( 
	SELECT 
	    user_id, 
	    COUNT(DISTINCT order_id) AS orders 
	  FROM orders 
	  GROUP BY user_id
  )
SELECT
	ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP(ORDER BY orders)::NUMERIC, 2) AS orders_p25,
	ROUND(PERCENTILE_CONT(0.50) WITHIN GROUP(ORDER BY orders)::NUMERIC,2) AS orders_p50,
	ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY orders):: NUMERIC,2) AS orders_p75,
	ROUND(AVG(orders)::NUMERIC,2) AS avg_orders
FROM
	user_orders
	






